/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.fluxtion.visualiser;

import com.mxgraph.io.mxGraphMlCodec;
import com.mxgraph.layout.hierarchical.mxHierarchicalLayout;
import com.mxgraph.model.mxCell;
import com.mxgraph.model.mxGraphModel;
import com.mxgraph.model.mxICell;
import com.mxgraph.swing.mxGraphComponent;
import com.mxgraph.util.mxCellRenderer;
import com.mxgraph.util.mxConstants;
import com.mxgraph.view.mxEdgeStyle;
import com.mxgraph.view.mxGraph;
import com.mxgraph.view.mxStylesheet;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import javax.imageio.ImageIO;
import javax.swing.JPanel;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.xml.sax.SAXException;

/**
 * Loads, displays and exports to PNG graphml files generated by Fluxtion.
 *
 *
 * @author Greg Higgins (greg.higgins@V12technology.com)
 */
public class GraphVisualiserPanel extends JPanel {

    private mxGraph graph;
    private mxGraphComponent graphComponent;
    private ArrayList<mxICell> highlightedCells;
    private ArrayList<mxICell> selectedCells;
    private mxHierarchicalLayout layoutImpl;

    public GraphVisualiserPanel() {
        setOpaque(true);
        setLayout(new BorderLayout());
        setBackground(Color.WHITE);
    }

    private List<mxICell> addParents(mxICell cell, boolean recurse, List<mxICell> cells) {
        for (Object o : graph.getIncomingEdges(cell)) {
            mxCell edge = (mxCell) o;
            mxICell source = edge.getSource();
            cells.add(source);
            cells.add(edge);
            if (recurse) {
                addParents(source, recurse, cells);
            }
        }
        return cells;
    }

    private List<mxICell> addChildren(mxICell cell, boolean recurse, List<mxICell> cells) {
        for (Object o : graph.getOutgoingEdges(cell)) {
            mxCell edge = (mxCell) o;
            mxICell target = edge.getTarget();
            cells.add(target);
            cells.add(edge);
            if (recurse) {
                addChildren(target, recurse, cells);
            }
        }
        return cells;
    }

    public void exportPng(File pngFile) {
        BufferedImage image = mxCellRenderer.createBufferedImage(graph, null, 1, Color.WHITE, true, null);
        if (pngFile.getParentFile().mkdirs()) {
            System.out.println("made directory");
        } else {
            System.out.println("FAILED to make directory");
        }
        try {
            ImageIO.write(image, "PNG", pngFile);
        } catch (IOException ex) {
            Logger.getLogger(GraphVisualiserPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public void load(File f) {
        loadMxGraph(f);
        configureDisplay();
    }

    public List<String> selectedIds() {
        List<String> ids = selectedCells.stream().map((m) -> m.getId()).collect(Collectors.toList());
        return ids;
    }

    public void selectCellsById(List<String> idList) {
        Object[] allCells = mxGraphModel.getChildren(graph.getModel(), graph.getDefaultParent());
        List<mxICell> matchingCells = Arrays.stream(allCells).map((t) -> (mxICell) t).filter((t) -> {
            return idList.contains(t.getId());
        }).collect(Collectors.toList());
        //grey everything
        graph.setCellStyles(mxConstants.STYLE_OPACITY, "10", allCells);
        graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, "grey", allCells);
        //
        for (mxICell selectedCell : matchingCells) {
            addParents(selectedCell, true, highlightedCells);
            addChildren(selectedCell, true, highlightedCells);
            selectedCells.add(selectedCell);
        }
        //highlight path nodes
        graph.setCellStyles(mxConstants.STYLE_OPACITY, "100", highlightedCells.toArray());
        graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, "black", highlightedCells.toArray());
        //red text for selected
        graph.setCellStyles(mxConstants.STYLE_OPACITY, "100", selectedCells.toArray());
        graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, "red", selectedCells.toArray());
    }

    public mxGraph loadMxGraph(File f) {
        graph = new mxGraph();

        Map<String, Object> styleDefault = graph.getStylesheet().getDefaultEdgeStyle();
        styleDefault.put(mxConstants.STYLE_EDGE, mxEdgeStyle.SideToSide);
        styleDefault.put(mxConstants.STYLE_DASHED, true);

        //style
        mxStylesheet stylesheet = graph.getStylesheet();
        Hashtable<String, Object> style = new Hashtable<>();
        style.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_RECTANGLE);
        style.put(mxConstants.STYLE_ROUNDED, true);
        style.put(mxConstants.STYLE_OPACITY, 100);
        style.put(mxConstants.STYLE_FILLCOLOR, "#53B9F0");
        style.put(mxConstants.STYLE_FONTCOLOR, "black");
        style.put(mxConstants.STYLE_WHITE_SPACE, "wrap");
        style.put(mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
//        style.put(mxConstants.STYLE_FONTSTYLE, mxConstants.FONT_BOLD);
        style.put(mxConstants.STYLE_FONTFAMILY, "Segoe");
        stylesheet.putCellStyle("EVENTHANDLER", style);

        style = new Hashtable<>();
        style.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_ELLIPSE);
        style.put(mxConstants.STYLE_ROUNDED, true);
        style.put(mxConstants.STYLE_OPACITY, 100);
        style.put(mxConstants.STYLE_FILLCOLOR, "#ffbf80");
        style.put(mxConstants.STYLE_FONTCOLOR, "black");
        style.put(mxConstants.STYLE_FONTFAMILY, "Segoe");
        style.put(mxConstants.STYLE_WHITE_SPACE, "wrap");
        style.put(mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
        style.put(mxConstants.STYLE_AUTOSIZE, 1);
        stylesheet.putCellStyle("EVENT", style);

        style = new Hashtable<>();
        style.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_RECTANGLE);
        style.put(mxConstants.STYLE_WHITE_SPACE, "wrap");
        style.put(mxConstants.STYLE_ROUNDED, true);
        style.put(mxConstants.STYLE_OPACITY, 100);
        mxConstants.SPLIT_WORDS = false;
        style.put(mxConstants.STYLE_FONTCOLOR, "black");
//        style.put(mxConstants.STYLE_FONTSTYLE, mxConstants.FONT_BOLD);
        style.put(mxConstants.STYLE_FILLCOLOR, "#53c68c");
        style.put(mxConstants.STYLE_FONTFAMILY, "Segoe");
        style.put(mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
        style.put(mxConstants.STYLE_AUTOSIZE, 1);
        stylesheet.putCellStyle("NODE", style);

        style = new Hashtable<>();
        style.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_CLOUD);
        style.put(mxConstants.STYLE_WHITE_SPACE, "wrap");
        style.put(mxConstants.STYLE_ROUNDED, true);
        style.put(mxConstants.STYLE_OPACITY, 100);
        mxConstants.SPLIT_WORDS = false;
        style.put(mxConstants.STYLE_FONTCOLOR, "red");
//        style.put(mxConstants.STYLE_FONTSTYLE, mxConstants.FONT_BOLD);
        style.put(mxConstants.STYLE_FILLCOLOR, "#346789");
        style.put(mxConstants.STYLE_FONTFAMILY, "Segoe");
        style.put(mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
        style.put(mxConstants.STYLE_AUTOSIZE, 1);
        stylesheet.putCellStyle("SELECTED", style);

        try {
            Document document = null;
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder parser = factory.newDocumentBuilder();
            document = parser.parse(f);
            Object parent = graph.getDefaultParent();
            mxGraphMlCodec.decode(document, graph);
            System.out.println("decoded graph:" + graph);
        } catch (SAXException | IOException | ParserConfigurationException ex) {
            Logger.getLogger(GraphVisualiserPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
        return graph;
    }

    private void configureDisplay() {
        highlightedCells = new ArrayList<>();
        selectedCells = new ArrayList<>();
        setOpaque(true);
        setLayout(new BorderLayout());
        graph.setCellsEditable(false);
        graph.setCellsMovable(false);
        graph.setCellsResizable(false);
        graph.setCellsDisconnectable(false);
        graph.setCellsLocked(true);
        graph.setConnectableEdges(false);
        Object parent = graph.getDefaultParent();

        layoutImpl = new mxHierarchicalLayout(graph);
        layoutImpl.setInterRankCellSpacing(80);
        layoutImpl.setIntraCellSpacing(70);
        layoutImpl.setFineTuning(true);
        layoutImpl.execute(parent);

        //swing component
        graphComponent = new mxGraphComponent(graph);
        graphComponent.getViewport().setOpaque(true);
        graphComponent.getViewport().setBackground(Color.WHITE);
        graphComponent.updateComponents();
        //click handler

        graphComponent.getGraphControl().addMouseListener(new MouseAdapter() {
            @Override
            public void mouseReleased(MouseEvent e1) {
                graph.getModel().beginUpdate();
                if (e1.getButton() == 1) {
                    if (!e1.isControlDown()) {
                        highlightedCells.clear();
                        selectedCells.clear();
                    }
                    final mxCell selectedCell = (mxCell) graphComponent.getCellAt(e1.getX(), e1.getY());
                    Object[] allCells = mxGraphModel.getChildren(graph.getModel(), graph.getDefaultParent());
                    if (selectedCell != null) {
                        final List<String> selectedIds = selectedIds();
                        if (selectedIds.contains(selectedCell.getId())) {
                            selectedIds.remove(selectedCell.getId());
                            highlightedCells.clear();
                            selectedCells.clear();
                            selectCellsById(selectedIds);
                        } else {
                            //set all grey
                            graph.setCellStyles(mxConstants.STYLE_OPACITY, "10", allCells);
                            graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, "grey", allCells);
                            //find all on path
                            boolean directsOnly = e1.getClickCount() == 2;
                            List<mxICell> cells = addParents(selectedCell, !directsOnly, highlightedCells);
                            mxICell[] cellsArray = addChildren(selectedCell, !directsOnly, cells).toArray(new mxICell[cells.size()]);
                            //highlight path nodes
                            graph.setCellStyles(mxConstants.STYLE_OPACITY, "100", cellsArray);
                            graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, "black", cellsArray);
                            //red text for selected
                            selectedCells.add(selectedCell);
                            graph.setCellStyles(mxConstants.STYLE_OPACITY, "100", selectedCells.toArray());
                            graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, "red", selectedCells.toArray());
                        }
                    } else {
                        graph.setCellStyles(mxConstants.STYLE_OPACITY, "100", allCells);
                        graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, "black", allCells);
                        highlightedCells.clear();
                        selectedCells.clear();
                    }
                }
                graph.getModel().endUpdate();
                invalidate();
                repaint();
            }
        });
        add(graphComponent, BorderLayout.CENTER);
        graphComponent.setCenterPage(true);
        graphComponent.zoomAndCenter();
    }

    public void foldCells(boolean fold) {
        graph.foldCells(fold);
        Object[] allCells = mxGraphModel.getChildren(graph.getModel(), graph.getDefaultParent());
        if (fold) {
            ArrayList list = new ArrayList();
            for (Object cell : allCells) {
                if (highlightedCells.contains(cell) || selectedCells.contains(cell)) {
                } else {
                    list.add(cell);
                }
            }
            allCells = list.toArray(new Object[list.size()]);
            graph.cellsRemoved(allCells);
            layoutImpl.setFineTuning(true);
            layoutImpl.execute(graph.getDefaultParent());
        }
    }

}
